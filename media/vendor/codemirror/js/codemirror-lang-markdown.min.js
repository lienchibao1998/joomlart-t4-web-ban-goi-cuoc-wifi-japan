import{EditorSelection as x,Prec as X,EditorState as K}from"@codemirror/state";import{keymap as V}from"@codemirror/view";import{syntaxTree as w,LanguageSupport as I,Language as j,defineLanguageFacet as G,foldNodeProp as Q,indentNodeProp as _,languageDataProp as z,foldService as J,LanguageDescription as M,ParseContext as U}from"@codemirror/language";import{CompletionContext as Y}from"@codemirror/autocomplete";import{MarkdownParser as Z,parseCode as W,parser as ee,GFM as te,Subscript as ne,Superscript as re,Emoji as oe}from"@lezer/markdown";import{htmlCompletionSource as le,html as ie}from"@codemirror/lang-html";import{NodeProp as se}from"@lezer/common";const T=G({commentTokens:{block:{open:"<!--",close:"-->"}}}),E=new se,D=ee.configure({props:[Q.add(n=>!n.is("Block")||n.is("Document")||B(n)!=null?void 0:(s,r)=>({from:r.doc.lineAt(s.from).to,to:s.to})),E.add(B),_.add({Document:()=>null}),z.add({Document:T})]});function B(n){let s=/^(?:ATX|Setext)Heading(\d)$/.exec(n.name);return s?+s[1]:void 0}function fe(n,s){let r=n;for(;;){let e=r.nextSibling,t;if(!e||(t=B(e.type))!=null&&t<=s)break;r=e}return r.to}const me=J.of((n,s,r)=>{for(let e=w(n).resolveInner(r,-1);e&&!(e.from<s);e=e.parent){let t=e.type.prop(E);if(t==null)continue;let f=fe(e,t);if(f>r)return{from:r,to:f}}return null});function b(n){return new j(T,n,[me],"markdown")}const N=b(D),ae=D.configure([te,ne,re,oe]),A=b(ae);function ue(n,s){return r=>{if(r&&n){let e=null;if(r=/\S*/.exec(r)[0],typeof n=="function"?e=n(r):e=M.matchLanguageName(n,r,!0),e instanceof M)return e.support?e.support.language.parser:U.getSkippingParser(e.load());if(e)return e.parser}return s?s.parser:null}}class L{constructor(s,r,e,t,f,i,a){this.node=s,this.from=r,this.to=e,this.spaceBefore=t,this.spaceAfter=f,this.type=i,this.item=a}blank(s,r=!0){let e=this.spaceBefore+(this.node.name=="Blockquote"?">":"");if(s!=null){for(;e.length<s;)e+=" ";return e}else{for(let t=this.to-this.from-e.length-this.spaceAfter.length;t>0;t--)e+=" ";return e+(r?this.spaceAfter:"")}}marker(s,r){let e=this.node.name=="OrderedList"?String(+O(this.item,s)[2]+r):"";return this.spaceBefore+e+this.type+this.spaceAfter}}function F(n,s){let r=[];for(let t=n;t&&t.name!="Document";t=t.parent)(t.name=="ListItem"||t.name=="Blockquote"||t.name=="FencedCode")&&r.push(t);let e=[];for(let t=r.length-1;t>=0;t--){let f=r[t],i,a=s.lineAt(f.from),o=f.from-a.from;if(f.name=="FencedCode")e.push(new L(f,o,o,"","","",null));else if(f.name=="Blockquote"&&(i=/^[ \t]*>( ?)/.exec(a.text.slice(o))))e.push(new L(f,o,o+i[0].length,"",i[1],">",null));else if(f.name=="ListItem"&&f.parent.name=="OrderedList"&&(i=/^([ \t]*)\d+([.)])([ \t]*)/.exec(a.text.slice(o)))){let m=i[3],l=i[0].length;m.length>=4&&(m=m.slice(0,m.length-4),l-=4),e.push(new L(f.parent,o,o+l,i[1],m,i[2],f))}else if(f.name=="ListItem"&&f.parent.name=="BulletList"&&(i=/^([ \t]*)([-+*])([ \t]{1,4}\[[ xX]\])?([ \t]+)/.exec(a.text.slice(o)))){let m=i[4],l=i[0].length;m.length>4&&(m=m.slice(0,m.length-4),l-=4);let p=i[2];i[3]&&(p+=i[3].replace(/[xX]/," ")),e.push(new L(f.parent,o,o+l,i[1],m,p,f))}}return e}function O(n,s){return/^(\s*)(\d+)(?=[.)])/.exec(s.sliceString(n.from,n.from+10))}function S(n,s,r,e=0){for(let t=-1,f=n;;){if(f.name=="ListItem"){let a=O(f,s),o=+a[2];if(t>=0){if(o!=t+1)return;r.push({from:f.from+a[1].length,to:f.from+a[0].length,insert:String(t+2+e)})}t=o}let i=f.nextSibling;if(!i)break;f=i}}const q=({state:n,dispatch:s})=>{let r=w(n),{doc:e}=n,t=null,f=n.changeByRange(i=>{if(!i.empty||!A.isActiveAt(n,i.from))return t={range:i};let a=i.from,o=e.lineAt(a),m=F(r.resolveInner(a,-1),e);for(;m.length&&m[m.length-1].from>a-o.from;)m.pop();if(!m.length)return t={range:i};let l=m[m.length-1];if(l.to-l.spaceAfter.length>a-o.from)return t={range:i};let p=a>=l.to-l.spaceAfter.length&&!/\S/.test(o.text.slice(l.to));if(l.item&&p)if(l.node.firstChild.to>=a||o.from>0&&!/[^\s>]/.test(e.lineAt(o.from-1).text)){let u=m.length>1?m[m.length-2]:null,c,d="";u&&u.item?(c=o.from+u.from,d=u.marker(e,1)):c=o.from+(u?u.to:0);let C=[{from:c,to:a,insert:d}];return l.node.name=="OrderedList"&&S(l.item,e,C,-2),u&&u.node.name=="OrderedList"&&S(u.item,e,C),{range:x.cursor(c+d.length),changes:C}}else{let u="";for(let c=0,d=m.length-2;c<=d;c++)u+=m[c].blank(c<d?m[c+1].from-u.length:null,c<d);return u+=n.lineBreak,{range:x.cursor(a+u.length),changes:{from:o.from,insert:u}}}if(l.node.name=="Blockquote"&&p&&o.from){let u=e.lineAt(o.from-1),c=/>\s*$/.exec(u.text);if(c&&c.index==l.from){let d=n.changes([{from:u.from+c.index,to:u.to},{from:o.from+l.from,to:o.to}]);return{range:i.map(d),changes:d}}}let h=[];l.node.name=="OrderedList"&&S(l.item,e,h);let P=l.item&&l.item.from<o.from,g="";if(!P||/^[\s\d.)\-+*>]*/.exec(o.text)[0].length>=l.to)for(let u=0,c=m.length-1;u<=c;u++)g+=u==c&&!P?m[u].marker(e,1):m[u].blank(u<c?m[u+1].from-g.length:null);let k=a;for(;k>o.from&&/\s/.test(o.text.charAt(k-o.from-1));)k--;return g=n.lineBreak+g,h.push({from:k,to:a,insert:g}),{range:x.cursor(k+g.length),changes:h}});return t?!1:(s(n.update(f,{scrollIntoView:!0,userEvent:"input"})),!0)};function $(n){return n.name=="QuoteMark"||n.name=="ListMark"}function ce(n,s){let r=n.resolveInner(s,-1),e=s;$(r)&&(e=r.from,r=r.parent);for(let t;t=r.childBefore(e);)if($(t))e=t.from;else if(t.name=="OrderedList"||t.name=="BulletList")r=t.lastChild,e=r.to;else break;return r}const H=({state:n,dispatch:s})=>{let r=w(n),e=null,t=n.changeByRange(f=>{let i=f.from,{doc:a}=n;if(f.empty&&A.isActiveAt(n,f.from)){let o=a.lineAt(i),m=F(ce(r,i),a);if(m.length){let l=m[m.length-1],p=l.to-l.spaceAfter.length+(l.spaceAfter?1:0);if(i-o.from>p&&!/\S/.test(o.text.slice(p,i-o.from)))return{range:x.cursor(o.from+p),changes:{from:o.from+p,to:i}};if(i-o.from==p&&(!l.item||o.from<=l.item.from||!/\S/.test(o.text.slice(0,l.to)))){let h=o.from+l.from;if(l.item&&l.node.from<l.item.from&&/\S/.test(o.text.slice(l.from,l.to)))return{range:f,changes:{from:h,to:o.from+l.to,insert:l.blank(l.to-l.from)}};if(h<i)return{range:x.cursor(h),changes:{from:h,to:i}}}}}return e={range:f}});return e?!1:(s(n.update(t,{scrollIntoView:!0,userEvent:"delete"})),!0)},R=[{key:"Enter",run:q},{key:"Backspace",run:H}],y=ie({matchClosingTags:!1});function pe(n={}){let{codeLanguages:s,defaultCodeLanguage:r,addKeymap:e=!0,base:{parser:t}=N,completeHTMLTags:f=!0}=n;if(!(t instanceof Z))throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");let i=n.extensions?[n.extensions]:[],a=[y.support],o;r instanceof I?(a.push(r.support),o=r.language):r&&(o=r);let m=s||o?ue(s,o):void 0;i.push(W({codeParser:m,htmlParser:y.language.parser})),e&&a.push(X.high(V.of(R)));let l=b(t.configure(i));return f&&a.push(l.data.of({autocomplete:de})),new I(l,a)}function de(n){let{state:s,pos:r}=n,e=/<[:\-\.\w\u00b7-\uffff]*$/.exec(s.sliceDoc(r-25,r));if(!e)return null;let t=w(s).resolveInner(r,-1);for(;t&&!t.type.isTop;){if(t.name=="CodeBlock"||t.name=="FencedCode"||t.name=="ProcessingInstructionBlock"||t.name=="CommentBlock"||t.name=="Link"||t.name=="Image")return null;t=t.parent}return{from:r-e[0].length,to:r,options:he(),validFor:/^<[:\-\.\w\u00b7-\uffff]*$/}}let v=null;function he(){if(v)return v;let n=le(new Y(K.create({extensions:y}),0,!0));return v=n?n.options:[]}export{N as commonmarkLanguage,H as deleteMarkupBackward,q as insertNewlineContinueMarkup,pe as markdown,R as markdownKeymap,A as markdownLanguage};
