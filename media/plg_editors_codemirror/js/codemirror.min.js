import{highlightSpecialChars as d,drawSelection as g,lineNumbers as p,EditorView as m,highlightActiveLineGutter as y,highlightActiveLine as w,keymap as l}from"@codemirror/view";export{EditorView,keymap}from"@codemirror/view";import{Compartment as E,EditorState as S}from"@codemirror/state";export{EditorState}from"@codemirror/state";import{syntaxHighlighting as k,defaultHighlightStyle as b,foldGutter as v}from"@codemirror/language";import{history as O,defaultKeymap as C,historyKeymap as c,emacsStyleKeymap as x}from"@codemirror/commands";import{highlightSelectionMatches as L,searchKeymap as K}from"@codemirror/search";import{closeBrackets as T}from"@codemirror/autocomplete";import{oneDark as B}from"@codemirror/theme-one-dark";/**
 * @copyright  (C) 2023 Open Source Matters, Inc. <https://www.joomla.org>
 * @license    GNU General Public License version 2 or later; see LICENSE.txt
 */const u=()=>[d(),O(),g(),k(b,{fallback:!0})],f=async e=>{const t=[],o=[];if(e.mode){const{mode:i}=e,s=e[i]||{};o.push(import(`@codemirror/lang-${e.mode}`).then(h=>{if(i==="php")return import("@codemirror/lang-html").then(({html:n})=>{const a=e.html||{selfClosingTags:!0};t.push(h.php({baseLanguage:n(a).language}))});i==="html"&&(s.selfClosingTags=!0),t.push(h[e.mode](s))}).catch(h=>{console.error(`Cannot create an extension for "${e.mode}" syntax mode.`,h)}))}switch(e.lineNumbers&&t.push(p()),e.lineWrapping&&t.push(m.lineWrapping),e.activeLine&&t.push(y(),w()),e.highlightSelection&&t.push(L()),e.autoCloseBrackets&&t.push(T()),e.foldGutter&&t.push(v()),e.keyMap){case"emacs":t.push(l.of([...x,...c]));break;default:t.push(l.of([...C,...K,...c]));break}const r=new E;return r.$j_name="readOnly",t.push(r.of(S.readOnly.of(!!e.readOnly))),"colorSchemeOs"in document.body.dataset&&window.matchMedia("(prefers-color-scheme: dark)").matches&&t.push(B),e.customExtensions&&e.customExtensions.length&&e.customExtensions.forEach(i=>{if(i instanceof Function){t.push(i());return}const[s,h]=i;o.push(import(s).then(n=>{h.forEach(a=>{t.push(n[a]())})}))}),Promise.all(o).then(()=>t)};async function G(e,t){const o=[u(),await f(t)],r=new m({doc:e.value,root:t.root||null,extensions:o});return e.parentNode.insertBefore(r.dom,e),e.style.display="none",e.form&&e.form.addEventListener("submit",()=>{e.value=r.state.doc.toString()}),t.width&&(r.dom.style.width=t.width),t.height&&(r.dom.style.height=t.height),r}export{G as createFromTextarea,u as minimalSetup,f as optionsToExtensions};
